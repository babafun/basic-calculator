/* LightningCalc - modularized app.js (moved into js/) */
(() => {
  // (original content moved here) -- file generated by assistant
  const display = document.getElementById('display');
  const controls = document.querySelector('.controls');

  let current = '0';
  let previous = null;
  let operator = null;
  let overwrite = false;

  function updateDisplay(){
    display.textContent = current;
  }

  function clearAll(){
    current = '0'; previous = null; operator = null; overwrite = false; updateDisplay();
  }

  function inputDigit(d){
    if(overwrite){ current = d === '.' ? '0.' : d; overwrite = false; updateDisplay(); return; }
    if(d === '.' && current.includes('.')) return;
    if(current === '0' && d !== '.') current = d; else current = current + d;
    updateDisplay();
  }

  function chooseOp(op){
    if(operator && !overwrite){ compute(); }
    operator = op;
    previous = current;
    overwrite = true;
  }

  function compute(){
    if(!operator || previous === null) return;

    // First try to use Decimal.js if available for robust arbitrary-precision decimals
    try{
      if(typeof Decimal !== 'undefined'){
        Decimal.set({ precision: 60, toExpNeg: -100, toExpPos: 100 });
        const a = new Decimal(previous);
        const b = new Decimal(current);
        let r;
        switch(operator){
          case 'add': r = a.plus(b); break;
          case 'subtract': r = a.minus(b); break;
          case 'multiply': r = a.times(b); break;
          case 'divide':
            if(b.isZero()){ current = 'Error'; operator = null; previous = null; overwrite = true; updateDisplay(); return; }
            r = a.div(b);
            break;
          default:
            r = null;
        }
        if(r === null){ current = 'Error'; }
        else {
          let s = r.toString();
          if(s.indexOf('.') >= 0) s = s.replace(/(\.\d*?)0+$/,'$1').replace(/\.$/, '');
          current = s;
        }
        operator = null; previous = null; overwrite = true; updateDisplay();
        return;
      }
    }catch(e){
      // if Decimal exists but parsing failed, fall back to internal compute
    }

    // Fallback: Precise arithmetic for large numbers using BigInt-based string math
    function parseNumberStr(s){
      const sign = s.trim().startsWith('-') ? -1 : 1;
      const ns = s.trim().replace(/^\+/, '');
      const parts = ns.replace(/^\+/, '').replace(/^\-/, '').split('.');
      const intPart = parts[0] || '0';
      const decPart = parts[1] || '';
      const digits = (intPart + decPart);
      const digitsNormalized = digits.replace(/^0+(?!$)/, '') || '0';
      return { sign, intPart, decPart, digits: digitsNormalized, decLen: decPart.length };
    }

    function bigIntFromParts(parts){ return BigInt(parts.digits); }

    function formatResult(bigIntVal, decLen, sign){
      let s = bigIntVal.toString();
      if(decLen > 0){
        if(s.length <= decLen) s = s.padStart(decLen + 1, '0');
        const intPortion = s.slice(0, s.length - decLen);
        let decPortion = s.slice(s.length - decLen);
        decPortion = decPortion.replace(/0+$/,'');
        if(decPortion === '') s = intPortion; else s = intPortion + '.' + decPortion;
      }
      s = s.replace(/^0+(?=\d)/, '');
      if(s === '') s = '0';
      if(sign < 0 && s !== '0') s = '-' + s;
      return s;
    }

    function computePrecise(aStr, bStr, op){
      const A = parseNumberStr(aStr);
      const B = parseNumberStr(bStr);
      if(op === 'add' || op === 'subtract'){
        const maxDec = Math.max(A.decLen, B.decLen);
        const scaleA = 10n ** BigInt(maxDec - A.decLen);
        const scaleB = 10n ** BigInt(maxDec - B.decLen);
        const aInt = bigIntFromParts(A) * scaleA * BigInt(A.sign);
        const bInt = bigIntFromParts(B) * scaleB * BigInt(B.sign);
        const res = op === 'add' ? aInt + bInt : aInt - bInt;
        const sign = res < 0n ? -1 : 1;
        const abs = res < 0n ? -res : res;
        return formatResult(abs, maxDec, sign);
      }
      if(op === 'multiply'){
        const aInt = bigIntFromParts(A) * BigInt(A.sign);
        const bInt = bigIntFromParts(B) * BigInt(B.sign);
        const res = aInt * bInt;
        const decLen = A.decLen + B.decLen;
        const sign = res < 0n ? -1 : 1;
        const abs = res < 0n ? -res : res;
        return formatResult(abs, decLen, sign);
      }
      if(op === 'divide'){
        const aInt = bigIntFromParts(A) * BigInt(A.sign);
        const bInt = bigIntFromParts(B) * BigInt(B.sign);
        if(bInt === 0n) return null;
        const PREC = 20;
        const scaleFactor = 10n ** BigInt(PREC + B.decLen - A.decLen);
        const numerator = BigInt(A.digits) * scaleFactor * BigInt(A.sign);
        const denominator = BigInt(B.digits) * BigInt(B.sign);
        const quotient = numerator / denominator;
        const sign = quotient < 0n ? -1 : 1;
        const abs = quotient < 0n ? -quotient : quotient;
        return formatResult(abs, PREC, sign);
      }
      return null;
    }

    const res = computePrecise(previous, current, operator);
    if(res === null) current = 'Error'; else current = res;
    operator = null; previous = null; overwrite = true; updateDisplay();
  }



  // History and Theme helpers
  const historyKey = 'lightningcalc_history_v1';
  const themeKey = 'lightningcalc_theme_v1';
  const historyListEl = document.getElementById('historyList');
  const historyPanel = document.getElementById('historyPanel');
  const historyToggle = document.getElementById('historyToggle');
  const clearHistoryBtn = document.getElementById('clearHistory');
  const themeToggle = document.getElementById('themeToggle');

  function loadHistory(){
    try{
      const raw = localStorage.getItem(historyKey) || '[]';
      return JSON.parse(raw);
    }catch(e){ return []; }
  }

  function saveHistory(arr){ localStorage.setItem(historyKey, JSON.stringify(arr.slice(0,5))); }

  function renderHistory(){
    const items = loadHistory();
    historyListEl.innerHTML = '';
    items.forEach(it => {
      const li = document.createElement('li'); li.textContent = it; historyListEl.appendChild(li);
    });
  }

  function addToHistory(entry){
    const items = loadHistory(); items.unshift(entry); saveHistory(items); renderHistory();
  }

  function clearHistory(){ localStorage.removeItem(historyKey); renderHistory(); }

  // Theme
  function applyTheme(theme){
    if(theme === 'light') document.documentElement.classList.add('light');
    else document.documentElement.classList.remove('light');
    if(themeToggle) themeToggle.setAttribute('aria-pressed', String(theme === 'light'));
    localStorage.setItem(themeKey, theme);
  }

  function loadTheme(){ return localStorage.getItem(themeKey) || 'dark'; }

  if(themeToggle){
    themeToggle.addEventListener('click', ()=>{
      const newTheme = document.documentElement.classList.contains('light') ? 'dark' : 'light';
      applyTheme(newTheme);
      themeToggle.textContent = newTheme === 'light' ? 'â˜€ï¸' : 'ðŸŒ™';
    });
  }

  if(historyToggle){
    historyToggle.addEventListener('click', ()=>{
      const expanded = historyToggle.getAttribute('aria-expanded') === 'true';
      historyToggle.setAttribute('aria-expanded', String(!expanded));
      historyPanel.setAttribute('aria-hidden', String(expanded));
    });
  }

  if(clearHistoryBtn) clearHistoryBtn.addEventListener('click', clearHistory);

  // integrate history when compute runs successfully
  const originalCompute = compute;
  function computeWithHistory(){
    // keep previous/current/operator for history text
    const prev = previous; const op = operator; const cur = current;
    originalCompute();
    if(prev !== null && op !== null){
      const symbol = op === 'add' ? '+' : op === 'subtract' ? '-' : op === 'multiply' ? 'Ã—' : op === 'divide' ? 'Ã·' : op;
      const entry = `${prev} ${symbol} ${cur} = ${current}`;
      addToHistory(entry);
    }
  }

  // replace compute references in handlers
  // update click handler mapping: if equals action call computeWithHistory
  controls.addEventListener('click', (e) => {
    const v = e.target.getAttribute('data-value');
    const action = e.target.getAttribute('data-action');
    if(v !== null){ inputDigit(v); return; }
    if(action){
      if(action === 'clear') clearAll();
      else if(action === 'equals') computeWithHistory();
      else chooseOp(action);
    }
  });

  // Keyboard: Enter should call computeWithHistory
  window.addEventListener('keydown', (e) => {
    if(e.key >= '0' && e.key <= '9') { inputDigit(e.key); e.preventDefault(); }
    else if(e.key === '.') { inputDigit('.'); e.preventDefault(); }
    else if(e.key === '+' ) chooseOp('add');
    else if(e.key === '-') chooseOp('subtract');
    else if(e.key === '*') chooseOp('multiply');
    else if(e.key === '/') chooseOp('divide');
    else if(e.key === 'Enter' || e.key === '=') { computeWithHistory(); e.preventDefault(); }
    else if(e.key === 'Escape') clearAll();
    else if(e.key === 'Backspace'){
      if(current === 'Error' || overwrite){ clearAll(); return; }
      current = current.length === 1 ? '0' : current.slice(0,-1); updateDisplay();
    }
  });

  // Initialize UI state
  renderHistory();
  applyTheme(loadTheme());
  updateDisplay();
})();
